<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>网络图测试 - 行列布局</title>
    <script src="https://cdn.jsdelivr.net/npm/vis-network@latest/standalone/umd/vis-network.min.js"></script>
    <style>
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
        background-color: #f5f5f5;
      }
      
      #network-container {
        width: 100%;
        height: 600px;
        border: 1px solid #ddd;
        background-color: #f9f9f9;
        margin: 20px 0;
      }
      
      .status {
        padding: 10px;
        background-color: #e8f4f8;
        border: 1px solid #bee5eb;
        border-radius: 4px;
        font-size: 14px;
        color: #0c5460;
        margin: 10px 0;
      }
      
      .info {
        background-color: #fff;
        padding: 15px;
        border-radius: 8px;
        margin-bottom: 20px;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
      }
    </style>
  </head>

  <body>
    <div class="info">
      <h1>网络图演示 - 行列布局</h1>
      <p><strong>布局说明：</strong></p>
      <ul>
        <li>第一行第一列：根节点</li>
        <li>第二列：直接子节点，按 Create_Time 从上到下排序（早的在上面）</li>
        <li>日期格式：13-Jul-2025 01:55:33</li>
        <li>从左往右为列布局</li>
      </ul>
    </div>
    
    <div id="network-container"></div>
    <div class="status" id="status">初始化中...</div>

    <script>
      // 解析自定义日期格式 (13-Jul-2025 01:55:33)
      function parseCustomDate(dateStr) {
        if (!dateStr) return new Date('1970-01-01');
        
        try {
          // 月份映射
          const monthMap = {
            'Jan': '01', 'Feb': '02', 'Mar': '03', 'Apr': '04',
            'May': '05', 'Jun': '06', 'Jul': '07', 'Aug': '08',
            'Sep': '09', 'Oct': '10', 'Nov': '11', 'Dec': '12'
          };
          
          // 解析格式: 13-Jul-2025 01:55:33
          const parts = dateStr.split(' ');
          if (parts.length !== 2) return new Date(dateStr);
          
          const datePart = parts[0]; // 13-Jul-2025
          const timePart = parts[1]; // 01:55:33
          
          const dateComponents = datePart.split('-');
          if (dateComponents.length !== 3) return new Date(dateStr);
          
          const day = dateComponents[0].padStart(2, '0');
          const month = monthMap[dateComponents[1]] || '01';
          const year = dateComponents[2];
          
          // 构建标准格式: YYYY-MM-DD HH:mm:ss
          const standardFormat = `${year}-${month}-${day} ${timePart}`;
          return new Date(standardFormat);
        } catch (error) {
          console.warn('日期解析失败:', dateStr, error);
          return new Date('1970-01-01');
        }
      }

      // 文字截断函数
      function truncateText(text, maxLength) {
        if (!text) return '';
        if (text.length <= maxLength) return text;
        return text.substring(0, maxLength) + '...';
      }

      // 获取节点颜色
      function getNodeColor(level) {
        const colors = [
          { border: '#e74c3c', background: '#fadbd8' }, // 红色 - 第1层 (根节点)
          { border: '#3498db', background: '#d6eaf8' }, // 蓝色 - 第2层 (直接子节点)
          { border: '#2ecc71', background: '#d5f4e6' }, // 绿色 - 第3层
        ];

        return colors[Math.min(level, colors.length - 1)];
      }

      // 测试数据 - 使用指定的日期格式
      const testData = [
        { id: 1, father_id: null, name: '根节点', create_time: '01-Jan-2025 09:00:00' },
        { id: 2, father_id: 1, name: '子节点A', create_time: '15-Jul-2025 14:30:15' },
        { id: 3, father_id: 1, name: '子节点B', create_time: '13-Jul-2025 01:55:33' },
        { id: 4, father_id: 1, name: '子节点C', create_time: '14-Jul-2025 08:20:45' },
        { id: 5, father_id: 2, name: '孙节点A1', create_time: '16-Jul-2025 10:15:22' },
        { id: 6, father_id: 2, name: '孙节点A2', create_time: '16-Jul-2025 09:45:11' },
        { id: 7, father_id: 3, name: '孙节点B1', create_time: '17-Jul-2025 16:30:00' }
      ];

      function initializeNetwork() {
        const container = document.getElementById('network-container');
        const nodes = new vis.DataSet();
        const edges = new vis.DataSet();

        // 构建节点映射
        const nodeMap = new Map();
        testData.forEach(item => nodeMap.set(item.id, item));

        // 找到根节点
        const rootNodes = testData.filter(
          item => item.father_id === null || item.father_id === undefined
        );

        // 构建层级结构
        const levels = new Map();
        const maxLevels = 3;

        function buildLevels(nodeId, level = 0) {
          if (level >= maxLevels) return;

          if (!levels.has(level)) levels.set(level, []);

          const node = nodeMap.get(nodeId);
          if (node) {
            levels.get(level).push(node);

            // 找子节点并按创建时间排序
            const children = testData.filter(item => item.father_id === nodeId);
            children.sort((a, b) => {
              const timeA = parseCustomDate(a.create_time || '01-Jan-1970 00:00:00');
              const timeB = parseCustomDate(b.create_time || '01-Jan-1970 00:00:00');
              return timeA - timeB; // 早的在前面
            });

            children.forEach(child => {
              buildLevels(child.id, level + 1);
            });
          }
        }

        rootNodes.forEach(root => buildLevels(root.id, 0));

        // 创建vis节点 - 行列布局，从左往右列布局
        const visNodes = [];
        const columnWidth = 300; // 列间距
        const rowHeight = 100;   // 行间距
        
        levels.forEach((levelNodes, level) => {
          // 计算垂直居中偏移
          const totalHeight = (levelNodes.length - 1) * rowHeight;
          const startY = -totalHeight / 2;
          
          levelNodes.forEach((node, index) => {
            visNodes.push({
              id: node.id,
              label: truncateText(node.name, 16),
              title: `${node.name}\n创建时间: ${node.create_time || '未知'}`,
              level: level,
              x: level * columnWidth, // X坐标按层级 (列)
              y: startY + index * rowHeight, // Y坐标按create_time排序 (行，早的在上面)
              fixed: { x: true, y: true }, // 固定位置
              color: getNodeColor(level),
              font: { size: 14, color: '#333' },
              borderWidth: 2,
              margin: 10,
              widthConstraint: { minimum: 150, maximum: 200 },
              heightConstraint: { minimum: 50 },
            });
          });
        });

        // 创建vis边
        const visEdges = [];
        levels.forEach(levelNodes => {
          levelNodes.forEach(node => {
            if (node.father_id !== null && nodeMap.has(node.father_id)) {
              const parentInView = visNodes.some(vn => vn.id === node.father_id);
              if (parentInView) {
                visEdges.push({
                  from: node.father_id,
                  to: node.id,
                  arrows: { to: { enabled: true, scaleFactor: 1 } },
                  color: '#7f8c8d',
                  width: 2,
                });
              }
            }
          });
        });

        // 网络配置
        const options = {
          layout: {
            hierarchical: {
              enabled: false,
            },
          },
          physics: { enabled: false },
          nodes: {
            shape: 'box',
            margin: 10,
            font: { size: 14, color: '#333' },
            borderWidth: 2,
            widthConstraint: { minimum: 150 },
            heightConstraint: { minimum: 40 },
          },
          edges: {
            arrows: { to: { enabled: true, scaleFactor: 1 } },
            color: '#7f8c8d',
            width: 2,
          },
          interaction: {
            dragNodes: true,
            dragView: true,
            zoomView: true,
          },
        };

        // 创建网络
        const network = new vis.Network(container, { nodes: visNodes, edges: visEdges }, options);

        // 更新状态
        document.getElementById('status').textContent = 
          `网络图加载完成: ${visNodes.length} 个节点, ${visEdges.length} 条边 (按创建时间排序)`;

        // 适应视图
        setTimeout(() => {
          network.fit();
        }, 200);

        // 添加点击事件
        network.on('click', function (params) {
          if (params.nodes.length > 0) {
            const nodeId = params.nodes[0];
            const nodeData = testData.find(n => n.id === nodeId);
            if (nodeData) {
              alert(`节点信息:\n名称: ${nodeData.name}\n创建时间: ${nodeData.create_time}`);
            }
          }
        });
      }

      // 页面加载完成后初始化
      window.addEventListener('load', function() {
        initializeNetwork();
      });
    </script>
  </body>
</html>